// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "job_archive.proto" (package "job_archive", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SourceState } from "./source";
import { Source } from "./source";
/**
 * @generated from protobuf message job_archive.JobParamArchive
 */
export interface JobParamArchive {
    /**
     * @generated from protobuf field: repeated source.Source sources = 1;
     */
    sources: Source[];
}
/**
 * @generated from protobuf message job_archive.JobArchiveNextParam
 */
export interface JobArchiveNextParam {
    /**
     * @generated from protobuf oneof: param
     */
    param: {
        oneofKind: "waitForTape";
        /**
         * @generated from protobuf field: job_archive.JobArchiveWaitForTapeParam WaitForTape = 1 [json_name = "WaitForTape"];
         */
        waitForTape: JobArchiveWaitForTapeParam;
    } | {
        oneofKind: "copying";
        /**
         * @generated from protobuf field: job_archive.JobArchiveCopyingParam Copying = 2 [json_name = "Copying"];
         */
        copying: JobArchiveCopyingParam;
    } | {
        oneofKind: "finished";
        /**
         * @generated from protobuf field: job_archive.JobArchiveFinishedParam Finished = 255 [json_name = "Finished"];
         */
        finished: JobArchiveFinishedParam;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message job_archive.JobArchiveWaitForTapeParam
 */
export interface JobArchiveWaitForTapeParam {
}
/**
 * @generated from protobuf message job_archive.JobArchiveCopyingParam
 */
export interface JobArchiveCopyingParam {
    /**
     * @generated from protobuf field: string device = 1;
     */
    device: string;
    /**
     * @generated from protobuf field: string barcode = 2;
     */
    barcode: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message job_archive.JobArchiveFinishedParam
 */
export interface JobArchiveFinishedParam {
}
/**
 * @generated from protobuf message job_archive.JobStateArchive
 */
export interface JobStateArchive {
    /**
     * @generated from protobuf field: job_archive.JobArchiveStep step = 1;
     */
    step: JobArchiveStep;
    /**
     * @generated from protobuf field: repeated source.SourceState sources = 2;
     */
    sources: SourceState[];
}
/**
 * @generated from protobuf message job_archive.JobDisplayArchive
 */
export interface JobDisplayArchive {
    /**
     * @generated from protobuf field: int64 copyedBytes = 1;
     */
    copyedBytes: bigint;
    /**
     * @generated from protobuf field: int64 copyedFiles = 2;
     */
    copyedFiles: bigint;
    /**
     * @generated from protobuf field: int64 totalBytes = 3;
     */
    totalBytes: bigint;
    /**
     * @generated from protobuf field: int64 totalFiles = 4;
     */
    totalFiles: bigint;
    /**
     * @generated from protobuf field: optional int64 speed = 5;
     */
    speed?: bigint;
    /**
     * @generated from protobuf field: int64 startTime = 6;
     */
    startTime: bigint;
}
/**
 * @generated from protobuf enum job_archive.JobArchiveStep
 */
export enum JobArchiveStep {
    /**
     * @generated from protobuf enum value: Pending = 0;
     */
    Pending = 0,
    /**
     * @generated from protobuf enum value: WaitForTape = 1;
     */
    WaitForTape = 1,
    /**
     * @generated from protobuf enum value: Copying = 2;
     */
    Copying = 2,
    /**
     * @generated from protobuf enum value: Finished = 255;
     */
    Finished = 255
}
// @generated message type with reflection information, may provide speed optimized methods
class JobParamArchive$Type extends MessageType<JobParamArchive> {
    constructor() {
        super("job_archive.JobParamArchive", [
            { no: 1, name: "sources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Source }
        ]);
    }
    create(value?: PartialMessage<JobParamArchive>): JobParamArchive {
        const message = { sources: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobParamArchive>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobParamArchive): JobParamArchive {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated source.Source sources */ 1:
                    message.sources.push(Source.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobParamArchive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated source.Source sources = 1; */
        for (let i = 0; i < message.sources.length; i++)
            Source.internalBinaryWrite(message.sources[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobParamArchive
 */
export const JobParamArchive = new JobParamArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveNextParam$Type extends MessageType<JobArchiveNextParam> {
    constructor() {
        super("job_archive.JobArchiveNextParam", [
            { no: 1, name: "WaitForTape", kind: "message", jsonName: "WaitForTape", oneof: "param", T: () => JobArchiveWaitForTapeParam },
            { no: 2, name: "Copying", kind: "message", jsonName: "Copying", oneof: "param", T: () => JobArchiveCopyingParam },
            { no: 255, name: "Finished", kind: "message", jsonName: "Finished", oneof: "param", T: () => JobArchiveFinishedParam }
        ]);
    }
    create(value?: PartialMessage<JobArchiveNextParam>): JobArchiveNextParam {
        const message = { param: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveNextParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveNextParam): JobArchiveNextParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job_archive.JobArchiveWaitForTapeParam WaitForTape = 1 [json_name = "WaitForTape"];*/ 1:
                    message.param = {
                        oneofKind: "waitForTape",
                        waitForTape: JobArchiveWaitForTapeParam.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).waitForTape)
                    };
                    break;
                case /* job_archive.JobArchiveCopyingParam Copying = 2 [json_name = "Copying"];*/ 2:
                    message.param = {
                        oneofKind: "copying",
                        copying: JobArchiveCopyingParam.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).copying)
                    };
                    break;
                case /* job_archive.JobArchiveFinishedParam Finished = 255 [json_name = "Finished"];*/ 255:
                    message.param = {
                        oneofKind: "finished",
                        finished: JobArchiveFinishedParam.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).finished)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveNextParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job_archive.JobArchiveWaitForTapeParam WaitForTape = 1 [json_name = "WaitForTape"]; */
        if (message.param.oneofKind === "waitForTape")
            JobArchiveWaitForTapeParam.internalBinaryWrite(message.param.waitForTape, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* job_archive.JobArchiveCopyingParam Copying = 2 [json_name = "Copying"]; */
        if (message.param.oneofKind === "copying")
            JobArchiveCopyingParam.internalBinaryWrite(message.param.copying, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* job_archive.JobArchiveFinishedParam Finished = 255 [json_name = "Finished"]; */
        if (message.param.oneofKind === "finished")
            JobArchiveFinishedParam.internalBinaryWrite(message.param.finished, writer.tag(255, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveNextParam
 */
export const JobArchiveNextParam = new JobArchiveNextParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveWaitForTapeParam$Type extends MessageType<JobArchiveWaitForTapeParam> {
    constructor() {
        super("job_archive.JobArchiveWaitForTapeParam", []);
    }
    create(value?: PartialMessage<JobArchiveWaitForTapeParam>): JobArchiveWaitForTapeParam {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveWaitForTapeParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveWaitForTapeParam): JobArchiveWaitForTapeParam {
        return target ?? this.create();
    }
    internalBinaryWrite(message: JobArchiveWaitForTapeParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveWaitForTapeParam
 */
export const JobArchiveWaitForTapeParam = new JobArchiveWaitForTapeParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveCopyingParam$Type extends MessageType<JobArchiveCopyingParam> {
    constructor() {
        super("job_archive.JobArchiveCopyingParam", [
            { no: 1, name: "device", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "barcode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JobArchiveCopyingParam>): JobArchiveCopyingParam {
        const message = { device: "", barcode: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveCopyingParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveCopyingParam): JobArchiveCopyingParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device */ 1:
                    message.device = reader.string();
                    break;
                case /* string barcode */ 2:
                    message.barcode = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveCopyingParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device = 1; */
        if (message.device !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.device);
        /* string barcode = 2; */
        if (message.barcode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.barcode);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveCopyingParam
 */
export const JobArchiveCopyingParam = new JobArchiveCopyingParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveFinishedParam$Type extends MessageType<JobArchiveFinishedParam> {
    constructor() {
        super("job_archive.JobArchiveFinishedParam", []);
    }
    create(value?: PartialMessage<JobArchiveFinishedParam>): JobArchiveFinishedParam {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveFinishedParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveFinishedParam): JobArchiveFinishedParam {
        return target ?? this.create();
    }
    internalBinaryWrite(message: JobArchiveFinishedParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveFinishedParam
 */
export const JobArchiveFinishedParam = new JobArchiveFinishedParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobStateArchive$Type extends MessageType<JobStateArchive> {
    constructor() {
        super("job_archive.JobStateArchive", [
            { no: 1, name: "step", kind: "enum", T: () => ["job_archive.JobArchiveStep", JobArchiveStep] },
            { no: 2, name: "sources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SourceState }
        ]);
    }
    create(value?: PartialMessage<JobStateArchive>): JobStateArchive {
        const message = { step: 0, sources: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobStateArchive>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobStateArchive): JobStateArchive {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job_archive.JobArchiveStep step */ 1:
                    message.step = reader.int32();
                    break;
                case /* repeated source.SourceState sources */ 2:
                    message.sources.push(SourceState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobStateArchive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job_archive.JobArchiveStep step = 1; */
        if (message.step !== 0)
            writer.tag(1, WireType.Varint).int32(message.step);
        /* repeated source.SourceState sources = 2; */
        for (let i = 0; i < message.sources.length; i++)
            SourceState.internalBinaryWrite(message.sources[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobStateArchive
 */
export const JobStateArchive = new JobStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobDisplayArchive$Type extends MessageType<JobDisplayArchive> {
    constructor() {
        super("job_archive.JobDisplayArchive", [
            { no: 1, name: "copyedBytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "copyedFiles", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "totalBytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "totalFiles", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "speed", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "startTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobDisplayArchive>): JobDisplayArchive {
        const message = { copyedBytes: 0n, copyedFiles: 0n, totalBytes: 0n, totalFiles: 0n, startTime: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobDisplayArchive>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobDisplayArchive): JobDisplayArchive {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 copyedBytes */ 1:
                    message.copyedBytes = reader.int64().toBigInt();
                    break;
                case /* int64 copyedFiles */ 2:
                    message.copyedFiles = reader.int64().toBigInt();
                    break;
                case /* int64 totalBytes */ 3:
                    message.totalBytes = reader.int64().toBigInt();
                    break;
                case /* int64 totalFiles */ 4:
                    message.totalFiles = reader.int64().toBigInt();
                    break;
                case /* optional int64 speed */ 5:
                    message.speed = reader.int64().toBigInt();
                    break;
                case /* int64 startTime */ 6:
                    message.startTime = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobDisplayArchive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 copyedBytes = 1; */
        if (message.copyedBytes !== 0n)
            writer.tag(1, WireType.Varint).int64(message.copyedBytes);
        /* int64 copyedFiles = 2; */
        if (message.copyedFiles !== 0n)
            writer.tag(2, WireType.Varint).int64(message.copyedFiles);
        /* int64 totalBytes = 3; */
        if (message.totalBytes !== 0n)
            writer.tag(3, WireType.Varint).int64(message.totalBytes);
        /* int64 totalFiles = 4; */
        if (message.totalFiles !== 0n)
            writer.tag(4, WireType.Varint).int64(message.totalFiles);
        /* optional int64 speed = 5; */
        if (message.speed !== undefined)
            writer.tag(5, WireType.Varint).int64(message.speed);
        /* int64 startTime = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).int64(message.startTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobDisplayArchive
 */
export const JobDisplayArchive = new JobDisplayArchive$Type();
