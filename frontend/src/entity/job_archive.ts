// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "job_archive.proto" (package "job_archive", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SourceState } from "./source";
import { Source } from "./source";
/**
 * @generated from protobuf message job_archive.JobArchiveParam
 */
export interface JobArchiveParam {
    /**
     * @generated from protobuf field: repeated source.Source sources = 1;
     */
    sources: Source[];
}
/**
 * @generated from protobuf message job_archive.JobArchiveDispatchParam
 */
export interface JobArchiveDispatchParam {
    /**
     * @generated from protobuf oneof: param
     */
    param: {
        oneofKind: "waitForTape";
        /**
         * @generated from protobuf field: job_archive.JobArchiveWaitForTapeParam wait_for_tape = 1;
         */
        waitForTape: JobArchiveWaitForTapeParam;
    } | {
        oneofKind: "copying";
        /**
         * @generated from protobuf field: job_archive.JobArchiveCopyingParam copying = 2;
         */
        copying: JobArchiveCopyingParam;
    } | {
        oneofKind: "finished";
        /**
         * @generated from protobuf field: job_archive.JobArchiveFinishedParam finished = 255;
         */
        finished: JobArchiveFinishedParam;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message job_archive.JobArchiveWaitForTapeParam
 */
export interface JobArchiveWaitForTapeParam {
}
/**
 * @generated from protobuf message job_archive.JobArchiveCopyingParam
 */
export interface JobArchiveCopyingParam {
    /**
     * @generated from protobuf field: string device = 1;
     */
    device: string;
    /**
     * @generated from protobuf field: string barcode = 2;
     */
    barcode: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message job_archive.JobArchiveFinishedParam
 */
export interface JobArchiveFinishedParam {
}
/**
 * @generated from protobuf message job_archive.JobArchiveState
 */
export interface JobArchiveState {
    /**
     * @generated from protobuf field: job_archive.JobArchiveStep step = 1;
     */
    step: JobArchiveStep;
    /**
     * @generated from protobuf field: repeated source.SourceState sources = 2;
     */
    sources: SourceState[];
}
/**
 * @generated from protobuf message job_archive.JobArchiveDisplay
 */
export interface JobArchiveDisplay {
    /**
     * @generated from protobuf field: int64 copied_bytes = 1;
     */
    copiedBytes: bigint;
    /**
     * @generated from protobuf field: int64 copied_files = 2;
     */
    copiedFiles: bigint;
    /**
     * @generated from protobuf field: int64 total_bytes = 3;
     */
    totalBytes: bigint;
    /**
     * @generated from protobuf field: int64 total_files = 4;
     */
    totalFiles: bigint;
    /**
     * @generated from protobuf field: optional int64 speed = 5;
     */
    speed?: bigint;
    /**
     * @generated from protobuf field: int64 start_time = 6;
     */
    startTime: bigint;
}
/**
 * @generated from protobuf enum job_archive.JobArchiveStep
 */
export enum JobArchiveStep {
    /**
     * @generated from protobuf enum value: PENDING = 0;
     */
    PENDING = 0,
    /**
     * @generated from protobuf enum value: WAIT_FOR_TAPE = 1;
     */
    WAIT_FOR_TAPE = 1,
    /**
     * @generated from protobuf enum value: COPYING = 2;
     */
    COPYING = 2,
    /**
     * @generated from protobuf enum value: FINISHED = 255;
     */
    FINISHED = 255
}
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveParam$Type extends MessageType<JobArchiveParam> {
    constructor() {
        super("job_archive.JobArchiveParam", [
            { no: 1, name: "sources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Source }
        ]);
    }
    create(value?: PartialMessage<JobArchiveParam>): JobArchiveParam {
        const message = { sources: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveParam): JobArchiveParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated source.Source sources */ 1:
                    message.sources.push(Source.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated source.Source sources = 1; */
        for (let i = 0; i < message.sources.length; i++)
            Source.internalBinaryWrite(message.sources[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveParam
 */
export const JobArchiveParam = new JobArchiveParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveDispatchParam$Type extends MessageType<JobArchiveDispatchParam> {
    constructor() {
        super("job_archive.JobArchiveDispatchParam", [
            { no: 1, name: "wait_for_tape", kind: "message", oneof: "param", T: () => JobArchiveWaitForTapeParam },
            { no: 2, name: "copying", kind: "message", oneof: "param", T: () => JobArchiveCopyingParam },
            { no: 255, name: "finished", kind: "message", oneof: "param", T: () => JobArchiveFinishedParam }
        ]);
    }
    create(value?: PartialMessage<JobArchiveDispatchParam>): JobArchiveDispatchParam {
        const message = { param: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveDispatchParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveDispatchParam): JobArchiveDispatchParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job_archive.JobArchiveWaitForTapeParam wait_for_tape */ 1:
                    message.param = {
                        oneofKind: "waitForTape",
                        waitForTape: JobArchiveWaitForTapeParam.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).waitForTape)
                    };
                    break;
                case /* job_archive.JobArchiveCopyingParam copying */ 2:
                    message.param = {
                        oneofKind: "copying",
                        copying: JobArchiveCopyingParam.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).copying)
                    };
                    break;
                case /* job_archive.JobArchiveFinishedParam finished */ 255:
                    message.param = {
                        oneofKind: "finished",
                        finished: JobArchiveFinishedParam.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).finished)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveDispatchParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job_archive.JobArchiveWaitForTapeParam wait_for_tape = 1; */
        if (message.param.oneofKind === "waitForTape")
            JobArchiveWaitForTapeParam.internalBinaryWrite(message.param.waitForTape, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* job_archive.JobArchiveCopyingParam copying = 2; */
        if (message.param.oneofKind === "copying")
            JobArchiveCopyingParam.internalBinaryWrite(message.param.copying, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* job_archive.JobArchiveFinishedParam finished = 255; */
        if (message.param.oneofKind === "finished")
            JobArchiveFinishedParam.internalBinaryWrite(message.param.finished, writer.tag(255, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveDispatchParam
 */
export const JobArchiveDispatchParam = new JobArchiveDispatchParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveWaitForTapeParam$Type extends MessageType<JobArchiveWaitForTapeParam> {
    constructor() {
        super("job_archive.JobArchiveWaitForTapeParam", []);
    }
    create(value?: PartialMessage<JobArchiveWaitForTapeParam>): JobArchiveWaitForTapeParam {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveWaitForTapeParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveWaitForTapeParam): JobArchiveWaitForTapeParam {
        return target ?? this.create();
    }
    internalBinaryWrite(message: JobArchiveWaitForTapeParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveWaitForTapeParam
 */
export const JobArchiveWaitForTapeParam = new JobArchiveWaitForTapeParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveCopyingParam$Type extends MessageType<JobArchiveCopyingParam> {
    constructor() {
        super("job_archive.JobArchiveCopyingParam", [
            { no: 1, name: "device", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "barcode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JobArchiveCopyingParam>): JobArchiveCopyingParam {
        const message = { device: "", barcode: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveCopyingParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveCopyingParam): JobArchiveCopyingParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device */ 1:
                    message.device = reader.string();
                    break;
                case /* string barcode */ 2:
                    message.barcode = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveCopyingParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device = 1; */
        if (message.device !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.device);
        /* string barcode = 2; */
        if (message.barcode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.barcode);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveCopyingParam
 */
export const JobArchiveCopyingParam = new JobArchiveCopyingParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveFinishedParam$Type extends MessageType<JobArchiveFinishedParam> {
    constructor() {
        super("job_archive.JobArchiveFinishedParam", []);
    }
    create(value?: PartialMessage<JobArchiveFinishedParam>): JobArchiveFinishedParam {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveFinishedParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveFinishedParam): JobArchiveFinishedParam {
        return target ?? this.create();
    }
    internalBinaryWrite(message: JobArchiveFinishedParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveFinishedParam
 */
export const JobArchiveFinishedParam = new JobArchiveFinishedParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveState$Type extends MessageType<JobArchiveState> {
    constructor() {
        super("job_archive.JobArchiveState", [
            { no: 1, name: "step", kind: "enum", T: () => ["job_archive.JobArchiveStep", JobArchiveStep] },
            { no: 2, name: "sources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SourceState }
        ]);
    }
    create(value?: PartialMessage<JobArchiveState>): JobArchiveState {
        const message = { step: 0, sources: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveState): JobArchiveState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job_archive.JobArchiveStep step */ 1:
                    message.step = reader.int32();
                    break;
                case /* repeated source.SourceState sources */ 2:
                    message.sources.push(SourceState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job_archive.JobArchiveStep step = 1; */
        if (message.step !== 0)
            writer.tag(1, WireType.Varint).int32(message.step);
        /* repeated source.SourceState sources = 2; */
        for (let i = 0; i < message.sources.length; i++)
            SourceState.internalBinaryWrite(message.sources[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveState
 */
export const JobArchiveState = new JobArchiveState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobArchiveDisplay$Type extends MessageType<JobArchiveDisplay> {
    constructor() {
        super("job_archive.JobArchiveDisplay", [
            { no: 1, name: "copied_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "copied_files", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "total_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_files", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "speed", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "start_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobArchiveDisplay>): JobArchiveDisplay {
        const message = { copiedBytes: 0n, copiedFiles: 0n, totalBytes: 0n, totalFiles: 0n, startTime: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobArchiveDisplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobArchiveDisplay): JobArchiveDisplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 copied_bytes */ 1:
                    message.copiedBytes = reader.int64().toBigInt();
                    break;
                case /* int64 copied_files */ 2:
                    message.copiedFiles = reader.int64().toBigInt();
                    break;
                case /* int64 total_bytes */ 3:
                    message.totalBytes = reader.int64().toBigInt();
                    break;
                case /* int64 total_files */ 4:
                    message.totalFiles = reader.int64().toBigInt();
                    break;
                case /* optional int64 speed */ 5:
                    message.speed = reader.int64().toBigInt();
                    break;
                case /* int64 start_time */ 6:
                    message.startTime = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobArchiveDisplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 copied_bytes = 1; */
        if (message.copiedBytes !== 0n)
            writer.tag(1, WireType.Varint).int64(message.copiedBytes);
        /* int64 copied_files = 2; */
        if (message.copiedFiles !== 0n)
            writer.tag(2, WireType.Varint).int64(message.copiedFiles);
        /* int64 total_bytes = 3; */
        if (message.totalBytes !== 0n)
            writer.tag(3, WireType.Varint).int64(message.totalBytes);
        /* int64 total_files = 4; */
        if (message.totalFiles !== 0n)
            writer.tag(4, WireType.Varint).int64(message.totalFiles);
        /* optional int64 speed = 5; */
        if (message.speed !== undefined)
            writer.tag(5, WireType.Varint).int64(message.speed);
        /* int64 start_time = 6; */
        if (message.startTime !== 0n)
            writer.tag(6, WireType.Varint).int64(message.startTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message job_archive.JobArchiveDisplay
 */
export const JobArchiveDisplay = new JobArchiveDisplay$Type();
