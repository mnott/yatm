// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "service.proto" (package "service", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SourceFile } from "./source";
import { JobDisplay } from "./job";
import { JobNextParam } from "./job";
import { CreatableJob } from "./job";
import { Job } from "./job";
import { JobFilter } from "./job";
import { Tape } from "./tape";
import { EditedFile } from "./file";
import { Position } from "./position";
import { File } from "./file";
/**
 * @generated from protobuf message service.FileGetRequest
 */
export interface FileGetRequest {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
}
/**
 * @generated from protobuf message service.FileGetReply
 */
export interface FileGetReply {
    /**
     * @generated from protobuf field: optional file.File file = 1;
     */
    file?: File;
    /**
     * @generated from protobuf field: repeated position.Position positions = 2;
     */
    positions: Position[];
    /**
     * @generated from protobuf field: repeated file.File children = 17;
     */
    children: File[];
}
/**
 * @generated from protobuf message service.FileEditRequest
 */
export interface FileEditRequest {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: file.EditedFile file = 2;
     */
    file?: EditedFile;
}
/**
 * @generated from protobuf message service.FileEditReply
 */
export interface FileEditReply {
    /**
     * @generated from protobuf field: file.File file = 1;
     */
    file?: File;
}
/**
 * @generated from protobuf message service.FileMkdirRequest
 */
export interface FileMkdirRequest {
    /**
     * @generated from protobuf field: int64 parent_id = 1;
     */
    parentId: bigint;
    /**
     * @generated from protobuf field: string path = 2;
     */
    path: string;
}
/**
 * @generated from protobuf message service.FileMkdirReply
 */
export interface FileMkdirReply {
    /**
     * @generated from protobuf field: file.File file = 1;
     */
    file?: File;
}
/**
 * @generated from protobuf message service.FileDeleteRequest
 */
export interface FileDeleteRequest {
    /**
     * @generated from protobuf field: repeated int64 ids = 1;
     */
    ids: bigint[];
}
/**
 * @generated from protobuf message service.FileDeleteReply
 */
export interface FileDeleteReply {
}
/**
 * @generated from protobuf message service.FileListParentsRequest
 */
export interface FileListParentsRequest {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
}
/**
 * @generated from protobuf message service.FileListParentsReply
 */
export interface FileListParentsReply {
    /**
     * @generated from protobuf field: repeated file.File parents = 1;
     */
    parents: File[];
}
/**
 * @generated from protobuf message service.TapeMGetRequest
 */
export interface TapeMGetRequest {
    /**
     * @generated from protobuf field: repeated int64 ids = 1;
     */
    ids: bigint[];
}
/**
 * @generated from protobuf message service.TapeMGetReply
 */
export interface TapeMGetReply {
    /**
     * @generated from protobuf field: repeated tape.Tape tapes = 1;
     */
    tapes: Tape[];
}
/**
 * @generated from protobuf message service.JobListRequest
 */
export interface JobListRequest {
    /**
     * @generated from protobuf oneof: param
     */
    param: {
        oneofKind: "mget";
        /**
         * @generated from protobuf field: service.JobMGetRequest mget = 1;
         */
        mget: JobMGetRequest;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: job.JobFilter list = 2;
         */
        list: JobFilter;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message service.JobMGetRequest
 */
export interface JobMGetRequest {
    /**
     * @generated from protobuf field: repeated int64 ids = 1;
     */
    ids: bigint[];
}
/**
 * @generated from protobuf message service.JobListReply
 */
export interface JobListReply {
    /**
     * @generated from protobuf field: repeated job.Job jobs = 1;
     */
    jobs: Job[];
}
/**
 * @generated from protobuf message service.JobCreateRequest
 */
export interface JobCreateRequest {
    /**
     * @generated from protobuf field: job.CreatableJob job = 1;
     */
    job?: CreatableJob;
}
/**
 * @generated from protobuf message service.JobCreateReply
 */
export interface JobCreateReply {
    /**
     * @generated from protobuf field: job.Job job = 1;
     */
    job?: Job;
}
/**
 * @generated from protobuf message service.JobNextRequest
 */
export interface JobNextRequest {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: job.JobNextParam param = 2;
     */
    param?: JobNextParam;
}
/**
 * @generated from protobuf message service.JobNextReply
 */
export interface JobNextReply {
    /**
     * @generated from protobuf field: job.Job job = 1;
     */
    job?: Job;
}
/**
 * @generated from protobuf message service.JobDisplayRequest
 */
export interface JobDisplayRequest {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
}
/**
 * @generated from protobuf message service.JobDisplayReply
 */
export interface JobDisplayReply {
    /**
     * @generated from protobuf field: job.JobDisplay display = 1;
     */
    display?: JobDisplay;
}
/**
 * @generated from protobuf message service.JobGetLogRequest
 */
export interface JobGetLogRequest {
    /**
     * @generated from protobuf field: int64 job_id = 1;
     */
    jobId: bigint;
    /**
     * @generated from protobuf field: optional int64 offset = 2;
     */
    offset?: bigint;
}
/**
 * @generated from protobuf message service.JobGetLogReply
 */
export interface JobGetLogReply {
    /**
     * @generated from protobuf field: bytes logs = 1;
     */
    logs: Uint8Array;
}
/**
 * @generated from protobuf message service.SourceListRequest
 */
export interface SourceListRequest {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * @generated from protobuf message service.SourceListReply
 */
export interface SourceListReply {
    /**
     * @generated from protobuf field: source.SourceFile file = 1;
     */
    file?: SourceFile;
    /**
     * @generated from protobuf field: repeated source.SourceFile chain = 2;
     */
    chain: SourceFile[];
    /**
     * @generated from protobuf field: repeated source.SourceFile children = 17;
     */
    children: SourceFile[];
}
/**
 * @generated from protobuf message service.DeviceListRequest
 */
export interface DeviceListRequest {
}
/**
 * @generated from protobuf message service.DeviceListReply
 */
export interface DeviceListReply {
    /**
     * @generated from protobuf field: repeated string devices = 1;
     */
    devices: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class FileGetRequest$Type extends MessageType<FileGetRequest> {
    constructor() {
        super("service.FileGetRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FileGetRequest>): FileGetRequest {
        const message = { id: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileGetRequest): FileGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileGetRequest
 */
export const FileGetRequest = new FileGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileGetReply$Type extends MessageType<FileGetReply> {
    constructor() {
        super("service.FileGetReply", [
            { no: 1, name: "file", kind: "message", T: () => File },
            { no: 2, name: "positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Position },
            { no: 17, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => File }
        ]);
    }
    create(value?: PartialMessage<FileGetReply>): FileGetReply {
        const message = { positions: [], children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileGetReply): FileGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional file.File file */ 1:
                    message.file = File.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                case /* repeated position.Position positions */ 2:
                    message.positions.push(Position.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated file.File children */ 17:
                    message.children.push(File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional file.File file = 1; */
        if (message.file)
            File.internalBinaryWrite(message.file, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated position.Position positions = 2; */
        for (let i = 0; i < message.positions.length; i++)
            Position.internalBinaryWrite(message.positions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated file.File children = 17; */
        for (let i = 0; i < message.children.length; i++)
            File.internalBinaryWrite(message.children[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileGetReply
 */
export const FileGetReply = new FileGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileEditRequest$Type extends MessageType<FileEditRequest> {
    constructor() {
        super("service.FileEditRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "file", kind: "message", T: () => EditedFile }
        ]);
    }
    create(value?: PartialMessage<FileEditRequest>): FileEditRequest {
        const message = { id: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileEditRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileEditRequest): FileEditRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* file.EditedFile file */ 2:
                    message.file = EditedFile.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileEditRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* file.EditedFile file = 2; */
        if (message.file)
            EditedFile.internalBinaryWrite(message.file, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileEditRequest
 */
export const FileEditRequest = new FileEditRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileEditReply$Type extends MessageType<FileEditReply> {
    constructor() {
        super("service.FileEditReply", [
            { no: 1, name: "file", kind: "message", T: () => File }
        ]);
    }
    create(value?: PartialMessage<FileEditReply>): FileEditReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileEditReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileEditReply): FileEditReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* file.File file */ 1:
                    message.file = File.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileEditReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* file.File file = 1; */
        if (message.file)
            File.internalBinaryWrite(message.file, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileEditReply
 */
export const FileEditReply = new FileEditReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileMkdirRequest$Type extends MessageType<FileMkdirRequest> {
    constructor() {
        super("service.FileMkdirRequest", [
            { no: 1, name: "parent_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileMkdirRequest>): FileMkdirRequest {
        const message = { parentId: 0n, path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileMkdirRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileMkdirRequest): FileMkdirRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 parent_id */ 1:
                    message.parentId = reader.int64().toBigInt();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileMkdirRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 parent_id = 1; */
        if (message.parentId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.parentId);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileMkdirRequest
 */
export const FileMkdirRequest = new FileMkdirRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileMkdirReply$Type extends MessageType<FileMkdirReply> {
    constructor() {
        super("service.FileMkdirReply", [
            { no: 1, name: "file", kind: "message", T: () => File }
        ]);
    }
    create(value?: PartialMessage<FileMkdirReply>): FileMkdirReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileMkdirReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileMkdirReply): FileMkdirReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* file.File file */ 1:
                    message.file = File.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileMkdirReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* file.File file = 1; */
        if (message.file)
            File.internalBinaryWrite(message.file, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileMkdirReply
 */
export const FileMkdirReply = new FileMkdirReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileDeleteRequest$Type extends MessageType<FileDeleteRequest> {
    constructor() {
        super("service.FileDeleteRequest", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FileDeleteRequest>): FileDeleteRequest {
        const message = { ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileDeleteRequest): FileDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int64().toBigInt());
                    else
                        message.ids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int64(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileDeleteRequest
 */
export const FileDeleteRequest = new FileDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileDeleteReply$Type extends MessageType<FileDeleteReply> {
    constructor() {
        super("service.FileDeleteReply", []);
    }
    create(value?: PartialMessage<FileDeleteReply>): FileDeleteReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileDeleteReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileDeleteReply): FileDeleteReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FileDeleteReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileDeleteReply
 */
export const FileDeleteReply = new FileDeleteReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileListParentsRequest$Type extends MessageType<FileListParentsRequest> {
    constructor() {
        super("service.FileListParentsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FileListParentsRequest>): FileListParentsRequest {
        const message = { id: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileListParentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileListParentsRequest): FileListParentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileListParentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileListParentsRequest
 */
export const FileListParentsRequest = new FileListParentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileListParentsReply$Type extends MessageType<FileListParentsReply> {
    constructor() {
        super("service.FileListParentsReply", [
            { no: 1, name: "parents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => File }
        ]);
    }
    create(value?: PartialMessage<FileListParentsReply>): FileListParentsReply {
        const message = { parents: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileListParentsReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileListParentsReply): FileListParentsReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated file.File parents */ 1:
                    message.parents.push(File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileListParentsReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated file.File parents = 1; */
        for (let i = 0; i < message.parents.length; i++)
            File.internalBinaryWrite(message.parents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.FileListParentsReply
 */
export const FileListParentsReply = new FileListParentsReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TapeMGetRequest$Type extends MessageType<TapeMGetRequest> {
    constructor() {
        super("service.TapeMGetRequest", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TapeMGetRequest>): TapeMGetRequest {
        const message = { ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TapeMGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapeMGetRequest): TapeMGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int64().toBigInt());
                    else
                        message.ids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapeMGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int64(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.TapeMGetRequest
 */
export const TapeMGetRequest = new TapeMGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TapeMGetReply$Type extends MessageType<TapeMGetReply> {
    constructor() {
        super("service.TapeMGetReply", [
            { no: 1, name: "tapes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tape }
        ]);
    }
    create(value?: PartialMessage<TapeMGetReply>): TapeMGetReply {
        const message = { tapes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TapeMGetReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapeMGetReply): TapeMGetReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tape.Tape tapes */ 1:
                    message.tapes.push(Tape.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapeMGetReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tape.Tape tapes = 1; */
        for (let i = 0; i < message.tapes.length; i++)
            Tape.internalBinaryWrite(message.tapes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.TapeMGetReply
 */
export const TapeMGetReply = new TapeMGetReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobListRequest$Type extends MessageType<JobListRequest> {
    constructor() {
        super("service.JobListRequest", [
            { no: 1, name: "mget", kind: "message", oneof: "param", T: () => JobMGetRequest },
            { no: 2, name: "list", kind: "message", oneof: "param", T: () => JobFilter }
        ]);
    }
    create(value?: PartialMessage<JobListRequest>): JobListRequest {
        const message = { param: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobListRequest): JobListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* service.JobMGetRequest mget */ 1:
                    message.param = {
                        oneofKind: "mget",
                        mget: JobMGetRequest.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).mget)
                    };
                    break;
                case /* job.JobFilter list */ 2:
                    message.param = {
                        oneofKind: "list",
                        list: JobFilter.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).list)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* service.JobMGetRequest mget = 1; */
        if (message.param.oneofKind === "mget")
            JobMGetRequest.internalBinaryWrite(message.param.mget, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* job.JobFilter list = 2; */
        if (message.param.oneofKind === "list")
            JobFilter.internalBinaryWrite(message.param.list, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobListRequest
 */
export const JobListRequest = new JobListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobMGetRequest$Type extends MessageType<JobMGetRequest> {
    constructor() {
        super("service.JobMGetRequest", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobMGetRequest>): JobMGetRequest {
        const message = { ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobMGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobMGetRequest): JobMGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int64().toBigInt());
                    else
                        message.ids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobMGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int64(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobMGetRequest
 */
export const JobMGetRequest = new JobMGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobListReply$Type extends MessageType<JobListReply> {
    constructor() {
        super("service.JobListReply", [
            { no: 1, name: "jobs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Job }
        ]);
    }
    create(value?: PartialMessage<JobListReply>): JobListReply {
        const message = { jobs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobListReply): JobListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated job.Job jobs */ 1:
                    message.jobs.push(Job.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated job.Job jobs = 1; */
        for (let i = 0; i < message.jobs.length; i++)
            Job.internalBinaryWrite(message.jobs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobListReply
 */
export const JobListReply = new JobListReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobCreateRequest$Type extends MessageType<JobCreateRequest> {
    constructor() {
        super("service.JobCreateRequest", [
            { no: 1, name: "job", kind: "message", T: () => CreatableJob }
        ]);
    }
    create(value?: PartialMessage<JobCreateRequest>): JobCreateRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobCreateRequest): JobCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job.CreatableJob job */ 1:
                    message.job = CreatableJob.internalBinaryRead(reader, reader.uint32(), options, message.job);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job.CreatableJob job = 1; */
        if (message.job)
            CreatableJob.internalBinaryWrite(message.job, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobCreateRequest
 */
export const JobCreateRequest = new JobCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobCreateReply$Type extends MessageType<JobCreateReply> {
    constructor() {
        super("service.JobCreateReply", [
            { no: 1, name: "job", kind: "message", T: () => Job }
        ]);
    }
    create(value?: PartialMessage<JobCreateReply>): JobCreateReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobCreateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobCreateReply): JobCreateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job.Job job */ 1:
                    message.job = Job.internalBinaryRead(reader, reader.uint32(), options, message.job);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobCreateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job.Job job = 1; */
        if (message.job)
            Job.internalBinaryWrite(message.job, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobCreateReply
 */
export const JobCreateReply = new JobCreateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobNextRequest$Type extends MessageType<JobNextRequest> {
    constructor() {
        super("service.JobNextRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "param", kind: "message", T: () => JobNextParam }
        ]);
    }
    create(value?: PartialMessage<JobNextRequest>): JobNextRequest {
        const message = { id: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobNextRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobNextRequest): JobNextRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* job.JobNextParam param */ 2:
                    message.param = JobNextParam.internalBinaryRead(reader, reader.uint32(), options, message.param);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobNextRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* job.JobNextParam param = 2; */
        if (message.param)
            JobNextParam.internalBinaryWrite(message.param, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobNextRequest
 */
export const JobNextRequest = new JobNextRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobNextReply$Type extends MessageType<JobNextReply> {
    constructor() {
        super("service.JobNextReply", [
            { no: 1, name: "job", kind: "message", T: () => Job }
        ]);
    }
    create(value?: PartialMessage<JobNextReply>): JobNextReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobNextReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobNextReply): JobNextReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job.Job job */ 1:
                    message.job = Job.internalBinaryRead(reader, reader.uint32(), options, message.job);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobNextReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job.Job job = 1; */
        if (message.job)
            Job.internalBinaryWrite(message.job, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobNextReply
 */
export const JobNextReply = new JobNextReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobDisplayRequest$Type extends MessageType<JobDisplayRequest> {
    constructor() {
        super("service.JobDisplayRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobDisplayRequest>): JobDisplayRequest {
        const message = { id: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobDisplayRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobDisplayRequest): JobDisplayRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobDisplayRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobDisplayRequest
 */
export const JobDisplayRequest = new JobDisplayRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobDisplayReply$Type extends MessageType<JobDisplayReply> {
    constructor() {
        super("service.JobDisplayReply", [
            { no: 1, name: "display", kind: "message", T: () => JobDisplay }
        ]);
    }
    create(value?: PartialMessage<JobDisplayReply>): JobDisplayReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobDisplayReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobDisplayReply): JobDisplayReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* job.JobDisplay display */ 1:
                    message.display = JobDisplay.internalBinaryRead(reader, reader.uint32(), options, message.display);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobDisplayReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* job.JobDisplay display = 1; */
        if (message.display)
            JobDisplay.internalBinaryWrite(message.display, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobDisplayReply
 */
export const JobDisplayReply = new JobDisplayReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobGetLogRequest$Type extends MessageType<JobGetLogRequest> {
    constructor() {
        super("service.JobGetLogRequest", [
            { no: 1, name: "job_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "offset", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobGetLogRequest>): JobGetLogRequest {
        const message = { jobId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobGetLogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobGetLogRequest): JobGetLogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 job_id */ 1:
                    message.jobId = reader.int64().toBigInt();
                    break;
                case /* optional int64 offset */ 2:
                    message.offset = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobGetLogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 job_id = 1; */
        if (message.jobId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.jobId);
        /* optional int64 offset = 2; */
        if (message.offset !== undefined)
            writer.tag(2, WireType.Varint).int64(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobGetLogRequest
 */
export const JobGetLogRequest = new JobGetLogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobGetLogReply$Type extends MessageType<JobGetLogReply> {
    constructor() {
        super("service.JobGetLogReply", [
            { no: 1, name: "logs", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<JobGetLogReply>): JobGetLogReply {
        const message = { logs: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JobGetLogReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobGetLogReply): JobGetLogReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes logs */ 1:
                    message.logs = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobGetLogReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes logs = 1; */
        if (message.logs.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.logs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.JobGetLogReply
 */
export const JobGetLogReply = new JobGetLogReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceListRequest$Type extends MessageType<SourceListRequest> {
    constructor() {
        super("service.SourceListRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SourceListRequest>): SourceListRequest {
        const message = { path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourceListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceListRequest): SourceListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.SourceListRequest
 */
export const SourceListRequest = new SourceListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceListReply$Type extends MessageType<SourceListReply> {
    constructor() {
        super("service.SourceListReply", [
            { no: 1, name: "file", kind: "message", T: () => SourceFile },
            { no: 2, name: "chain", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SourceFile },
            { no: 17, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SourceFile }
        ]);
    }
    create(value?: PartialMessage<SourceListReply>): SourceListReply {
        const message = { chain: [], children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourceListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceListReply): SourceListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* source.SourceFile file */ 1:
                    message.file = SourceFile.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                case /* repeated source.SourceFile chain */ 2:
                    message.chain.push(SourceFile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated source.SourceFile children */ 17:
                    message.children.push(SourceFile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* source.SourceFile file = 1; */
        if (message.file)
            SourceFile.internalBinaryWrite(message.file, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated source.SourceFile chain = 2; */
        for (let i = 0; i < message.chain.length; i++)
            SourceFile.internalBinaryWrite(message.chain[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated source.SourceFile children = 17; */
        for (let i = 0; i < message.children.length; i++)
            SourceFile.internalBinaryWrite(message.children[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.SourceListReply
 */
export const SourceListReply = new SourceListReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceListRequest$Type extends MessageType<DeviceListRequest> {
    constructor() {
        super("service.DeviceListRequest", []);
    }
    create(value?: PartialMessage<DeviceListRequest>): DeviceListRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceListRequest): DeviceListRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeviceListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DeviceListRequest
 */
export const DeviceListRequest = new DeviceListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceListReply$Type extends MessageType<DeviceListReply> {
    constructor() {
        super("service.DeviceListReply", [
            { no: 1, name: "devices", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceListReply>): DeviceListReply {
        const message = { devices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceListReply): DeviceListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string devices */ 1:
                    message.devices.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.devices[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DeviceListReply
 */
export const DeviceListReply = new DeviceListReply$Type();
/**
 * @generated ServiceType for protobuf service service.Service
 */
export const Service = new ServiceType("service.Service", [
    { name: "FileGet", options: {}, I: FileGetRequest, O: FileGetReply },
    { name: "FileEdit", options: {}, I: FileEditRequest, O: FileEditReply },
    { name: "FileMkdir", options: {}, I: FileMkdirRequest, O: FileMkdirReply },
    { name: "FileDelete", options: {}, I: FileDeleteRequest, O: FileDeleteReply },
    { name: "FileListParents", options: {}, I: FileListParentsRequest, O: FileListParentsReply },
    { name: "TapeMGet", options: {}, I: TapeMGetRequest, O: TapeMGetReply },
    { name: "JobList", options: {}, I: JobListRequest, O: JobListReply },
    { name: "JobCreate", options: {}, I: JobCreateRequest, O: JobCreateReply },
    { name: "JobNext", options: {}, I: JobNextRequest, O: JobNextReply },
    { name: "JobDisplay", options: {}, I: JobDisplayRequest, O: JobDisplayReply },
    { name: "JobGetLog", options: {}, I: JobGetLogRequest, O: JobGetLogReply },
    { name: "SourceList", options: {}, I: SourceListRequest, O: SourceListReply },
    { name: "DeviceList", options: {}, I: DeviceListRequest, O: DeviceListReply }
]);
